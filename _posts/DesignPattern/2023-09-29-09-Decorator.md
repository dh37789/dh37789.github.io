---
title: "[DesignPattern] 데코레이터 (Decorator)"

layout: post
categories: DesignPattern

toc: true
toc_sticky: DesignPattern

date: 2023-09-29
last_modified_at: 2023-09-29
---

# 데코레이터 (Decorator)

객체에 동적으로 새로운 책임을 추가할 수 있게 합니다. 기능을 추가하려면, 서브클래스를 생성하는 것보다 융통성 있는 방법을 제공합니다.


## 다른 이름

랩퍼(Wrapper)


## 동기

가끔 전체 클래스에 새로운 기능을 추가할 필요는 없지만, 개별적인 객체에 새로운 책임을 추가할 필요가 있다. 새로운 서비스의 추가가 필요할 떄 이를 해결하는 일반적인 방법은 상속을 이용하는 것이다.

즉, 이미 존재하는 클래스를 상속받고, 또 다른 클래스에서 테두리 속성을 상속받아 이 서브클래스의 인스턴스에 테두리가 있도록 하는 방법이지만 별로 유용하지 않다.

더 나은 방법은 지금 필요한 테두리를 추가하는 다른 객체에다가 해당 구성요소를 둘러싸는 것이다. 이렇게 무엇인가를 감싸는 객체를 데코레이터(decorator)라고 한다.

데코레이터는 자신이 둘러싼 요소, 구성요소가 갖는 인터페이스를 자신도 동일하게 제공하므로, 데코레이터 객체의 존재는 이를 사용하는 사용자에게 감춰진다.


## 활용성

장식자 패턴은 다음의 경우에 사용한다.

- 동적으로 또한 투명하게(transparent), 다시 말해 다른 객체에 영향을 주지 않고 개개의 객체에 새로운 책임을 추가하기 위해 사용한다.
- 제거될 수 있는 책임에 대해 사용한다.
- 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용한다.


## 구조

![데코레이터 구조]({{site.url}}/public/image/2023/2023-09/29-deco001.png)

- Component: 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스
- ConcreteComponent: 추가적인 서비스가 실제로 정의되어야 할 필요가 있는 객체
- Decorator: Component 객체에 대한 참조자를 관리하면서 Cmoponent에 정의된 인터페이스를 만족하도록 인터페이스를 정의
- ConcreteDecorator: Component에 새롭게 추가할 서비스를 실제로 구현하는 클래스


## 결과

데코레이터 패턴을 쓰면서 얻는 이익과 부담은 각각 두가지 이다.

- 단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있다.
- 클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있다.
- 데코레이터와 해당 그 데코레이터의 구성요소가 동일한 것은 아니다.
- 데코레이터를 사용함으로써 작은 규모의 객체들이 많이 생긴다.
