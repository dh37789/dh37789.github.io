---
title:  "[Gold5] No.02493 탑"

categories: baekjoon

toc: true
toc_sticky: true

date: 2022-03-01
last_modified_at: 2022-03-01
---

# 탑

[No.02493 탑](https://www.acmicpc.net/problem/2493)

## 문제

KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.

예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.

탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라. 

## 풀이

해당 문제를 처음에는 주어진 배열을 모두 스택에 넣고 for문을 돌렸는데, 메모리 초과 에러가 계속 발생하였다.  
문제에서 주어진 N의 수가 1 이상 500,000 이하의 수이기 때문에, for문으로 무작정 돌리면 시간 초과 및 메모리 초과가 발생한다.  
여담으로, 데이터를 입력받는 경우 Scanner를 사용하지 않고 BufferedReader를 사용해야 메모리 초과를 피할 수 있다.

주어진 문제에서  **높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자.** 해당 항목에서 First In Last Out인 것을 보아 Stack을 이용해 문제를 풀이하라는 것을 유추 할 수 있다.

그럼 문제를 그림으로 나타내 보자.  
주어진 6, 9, 5, 7, 4인 다섯 개의 탑을 그림으로 나타내면 아래처럼 그려진다.

![타워도식화1]({{site.url}}/assets/image/2022-03-01/tower001.PNG )

이제 왼쪽 방향으로 발사하는 레이저 신호를 추가 해보자.

![타워도식화2]({{site.url}}/assets/image/2022-03-01/tower002.PNG )

해당 그림을 통해 알 수 있는것은
- 첫번째 탑인 높이가 6인 탑은 수신받을 수 있는 탑이 없다.
- 두번째 탑인 높이가 9인 탑은 수신받을 수 있는 탑이 없다.
- 세번째 탑인 높이가 5인 탑은 두번째 탑이 수신 받았다.
- 네번째 탑인 높이가 7인 탑은 두번째 탑이 수신 받았다.
- 다섯번째 탑인 높이가 4인 탑은 네번째 탑이 수신받았다.

정리하자면  
- 이전 탑의 길이 < 현재 탑의 길이 : 필요 없으므로 제거(pop)  
- 이전 탑의 길이 > 현재탑의 길이 : 이전 탑의 index를 출력하고 현재탑을 push  
하면 된다.  

해당 로직을 Stack에 적용해보자

- 첫번째 탑 (높이 : 6)  
  1) Stack []  
  2) 첫번째 탑은 왼쪽으로 수신 할 수 있는 탑이 없다. -> 0을 출력  
  3) 스택이 비어있으므로, 스택에 push를 해준다.  

- 두번째 탑 (높이 : 9)  
  1) Stack [6]  
  2) 두번째 탑보다 첫번째 탑이 작다. -> 첫번째 탑 pop  
  3) 왼쪽으로 두번째 탑보다 높은 탑이없으니 수신 할 수 있는 탑이 없다 -> 0을 출력  
  4) 스택에 두번째 탑을 push 해준다.  

- 세번째 탑 (높이 : 5)  
  1) Stack [9]
  2) 세번째 탑보다 두번째 탑이 크다. -> 2를 출력  
  3) 스택에 세번째 탑을 push 해준다.  

- 네번째 탑 (높이 : 7)  
  1) Stack [9,5]
  2) 네번째 탑보다 세번째 탑이 작다 -> 세번째 탑 pop  
  3) 네번째 탑보다 두번째 탑이 크다 -> 2를 출력
  4) 스택에 네번째 탑을 push 해준다.

- 다섯번째 탑 (높이 : 4)  
  1) Stack [9,7]
  2) 다섯번째 탑보다 네번째 탑이 크다. -> 4를 출력
  3) 스택에 다섯번쨰 탑을 push 해준다.  
  
## 풀이 소스

```java
import java.io.*;
import java.util.Stack;
import java.util.StringTokenizer;

public class Main {
    /** 타워의 객체 */
    public static class Tower{
        int idx;
        int height;

        public int getIdx() {
            return idx;
        }

        public int getHeight() {
            return height;
        }

        public Tower(int idx, int height){
            this.idx = idx;
            this.height = height;
        }
    }

    public static void main(String[] args) throws IOException {
        /** n이 1이상 500,000 이하이므로 Scanner 사용시 메모리 초과 */
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine());

        StringTokenizer sToken = new StringTokenizer(br.readLine());
        Stack<Tower> stack = new Stack<Tower>();

        for (int i = 0; i < n; i++) {
            /** 현재 타워의 높이 정보를 가져온다. */
            int tmpHeight = Integer.parseInt(sToken.nextToken());
            
            /** stack이 비어있을 경우 0을 출력하고 push */
            if(stack.isEmpty()){
                stack.push(new Tower(i + 1, tmpHeight));
                bw.write("0 ");
                continue;
            }

            /** 현재 탑의 높이와 stack에 저장된 탑의 정보를 비교 */
            while(!stack.isEmpty()){
                
                /** stack에서 FILO으로 뽑아온 타워의 높이가 
                 * 현재 탑의 높이보다 클 경우 
                 * stack에 저장된 타워의 index를 출력한다. 
                 * 반면, 반대의 경우 stack에서 해당 탑의 정보를 제거한다. */
                if(tmpHeight < stack.peek().height){
                    bw.write(stack.peek().idx + " ");
                    break;
                } else {
                    stack.pop();
                }
            }

            /** 전부 pop되서 제거됬을 경우 0을 출력 */
            if (stack.isEmpty()){
                bw.write("0 ");
            }
            
            /** 현재 탑의 정보를 stack에 저장 */
            stack.push(new Tower(i + 1, tmpHeight));
        }

        bw.flush();
        bw.close();
        br.close();
    }
}
```



  


