---
title:  "[Refactoring] 냄새 11. 기본형 집착"

categories: Refactoring

toc: true
toc_sticky: true

date: 2023-01-03
last_modified_at: 2023-01-03
---

해당 포스트는 inflearn의 백기선님의 강의인 [리팩토링](https://www.inflearn.com/course/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81) 을 듣고 정리한 글입니다.

# 냄새 11. 기본형 집착

- 애플리케이션이 다루고 있는 도메인에 필요한 기본 타입을 만들지 않고 프로그래밍 언어가 제공하는 기본타입을 사용하는 경우가 많다.
  - 예) 전화번호, 좌표, 돈, 범위, 수량 등
- 기본형으로는 단위 (인치 vs 미터) 또는 표기법을 표현하기 어렵다.
- 관련 리팩토링 기술
  - **"기본형을 객체로 바꾸기 (Replace Primitive with Object)"**
  - **"타입 코드를 서브클래스로 바꾸기 (Replace Type Code with Subclasses)"**
  - **"조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)"**
  - "클래스 추출하기 (Extract Class)"
  - "매개변수 객체 만들기 (Introduce Parameter Object)"

## 리팩토링 30. 기본형을 객체로 바꾸기

- 개발 초기에는 기본형 (숫자 또는 문자열)으로 표현한 데이터가 나중에는 해당 데이터와 관련있는 다양한 기능을 필요로 하는 경우가 발생한다.
  - 예) 문자열로 표현하던 전화번호의 지역 코드가 필요하거나 다양한 포맷을 지원 하는 경우.
  - 예) 숫자로 표현하던 온도의 단위 (화씨, 섭씨)를 변환 하는 경우.
- 기본형을 사용한 데이터를 감싸 줄 클래스를 만들면, 필요한 기능을 추가할 수 있다.

- Order

```java
public class Order {

    private String priority;

    public Order(String priority) {
        this.priority = priority;
    }

    public String getPriority() {
        return priority;
    }
}
```

- OrderProcessor

```java
public class OrderProcessor {

    public long numberOfHighPriorityOrders(List<Order> orders) {
        return orders.stream()
                .filter(o -> o.getPriority() == "high" || o.getPriority() == "rush")
                .count();
    }
}
```

해당 코드는 `Order`의 주문 정보의 우선순위(priority)를 String 으로 받고, `OrderProcessor`에서 high와 rush의 빈도수를 계산하는 로직이다.

먼저 테스트코드는 아래와 같이 작성되었으며, 테스트가 돌아가는지 실행해 보자.

```java
@Test
void numberOfHighPriorityOrders() {
    OrderProcessor orderProcessor = new OrderProcessor();
    long highPriorityOrders = orderProcessor.numberOfHighPriorityOrders(
            List.of(new Order("low"),
                    new Order("normal"),
                    new Order("high"),
                    new Order("rush")));
    assertEquals(2, highPriorityOrders);
}
```

정상적으로 돌아가는 것을 확인 할 수 있다.

![리팩토링001]({{site.url}}/assets/image/2023/2023-01/03-refact001.png)

먼저 String 타입으로 받던 `priority` 를 클래스로 추출해주자.  

String으로 받아준다면, `priority`변수에 'ㄱ'이나 'ㄴ'같은 문자를 넣어도 아무 문자나 들어갈 수 있기 때문에 Type Safety가 보장되지 않기 때문이다.

이렇게 `Priority` 클래스로 따로 추출해 준 뒤 `low`, `normal` `high`, `rush` 네가지 타입 외에는 `IllegalArgumentException` 예외처리를 반환하도록 하여 데이터의 정합성을 높여준다.  
이후 해당 타입별로 필요한 메소드들을 구현해준다.

여기서 각각의 `higherThan`와 `index`는 `OrderProcessor`의 로직중 filter 부분의 책임을 `Priority`로 옮겼다고 보면 된다. 

```java
public class Priority {

    private String value;

    private List<String> legalValues = List.of("low", "normal", "high", "rush");

    public Priority(String value) {
        if (this.legalValues.contains(value))
            this.value = value;
        else
            throw new IllegalArgumentException("illegal value for priority " + value);
    }

    @Override
    public String toString() {
        return this.value;
    }

    public int index() {
        return this.legalValues.indexOf(this.value);
    }

    public boolean higherThan(Priority other) {
        return this.index() > other.index();
    }
}
```

그러면 나머지 `Order`과 `OrderProcessor`의 로직도 변경 해 주도록 하자.

여기서 중요한것이, 리팩토링으로 인한 side effect가 걱정될 경우 String 타입을 생성자로 받는 그대로 사용하여 `Priority`객체로 넘겨주면 된다.  
이 기술을 메소드 체이닝이라고 하는데, 체이닝을 통하여 기존 코드의 변경없이도 리팩토링을 진행 할 수 있다.

- Order

```java
public class Order {

    private Priority priority;

    // 메소드 체이닝(Method Chaining)
    public Order(String priorityValue) {
        this(new Priority(priorityValue));
    }

    public Order(Priority priority) {
        this.priority = priority;
    }

    public Priority getPriority() {
        return this.priority;
    }
}
```

`OrderProcessor`의 경우 앞서 설명한대로, OR 조건을 제거하고, `Priority`객체에서 우선순위를 비교하여, 반환하도록 변경하였다.

- OrderProcessor

```java
public class OrderProcessor {

    public long numberOfHighPriorityOrders(List<Order> orders) {
        return orders.stream()
                .filter(o -> o.getPriority().higherThan(new Priority("normal")))
                .count();
    }
}
```

다시 테스트를 돌려본다면, 동일한 결과가 나오는것을 확인 할 수 있다.

![리팩토링002]({{site.url}}/assets/image/2023/2023-01/03-refact002.png)


##